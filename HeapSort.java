
public class HeapSort {
    int size;

    // Sort the given array using the Heap Sort algorithm
    public void heapSort(Cve[] content) {
        size = content.length;

        // Build the initial max heap
        for (int i = (content.length / 2) - 1; i >= 0; i--) {
            heapify(content, i);
        }

        // Sort the heap and extract elements
        for (int i = content.length - 1; i > 0; i--) {
            // Swap the root element (max) with the last element and reduce the heap size
            swap(content, 0, i);
            size--;
            // Rebuild the heap with the reduced size
            heapify(content, 0);
        }
    }

    // Transform the subtree rooted at root_index into a max heap
    private void heapify(Cve[] arr, int root_index) {
        int max_index = root_index;
        int left_child_index = 2 * root_index + 1;
        int right_child_index = 2 * root_index + 2;

        // Check if the left child is in bounds and greater than the current max
        if (left_child_index < size && compareCve(arr[left_child_index], arr[max_index]) > 0) {
            max_index = left_child_index;
        }

        // Check if the right child is in bounds and greater than the current max
        if (right_child_index < size && compareCve(arr[right_child_index], arr[max_index]) > 0) {
            max_index = right_child_index;
        }

        // If the root element is not the maximum, swap it with the maximum element
        if (max_index != root_index) {
            swap(arr, root_index, max_index);
            // Recursively heapify the affected subtree
            heapify(arr, max_index);
        }
    }

    // Swap elements in the array
    private void swap(Cve[] arr, int a, int b) {
        Cve temp = arr[a];
        arr[a] = arr[b];
        arr[b] = temp;
    }

    // Compare two Cve objects based on their CVSS metrics and ID
    private int compareCve(Cve a, Cve b) {
        if (a.metrics.cvssMetricV2 != null && b.metrics.cvssMetricV2 != null) {
            double baseScoreA = a.metrics.cvssMetricV2.get(0).cvssData.baseScore;
            double baseScoreB = b.metrics.cvssMetricV2.get(0).cvssData.baseScore;
            double impactScoreA = a.metrics.cvssMetricV2.get(0).impactScore;
            double impactScoreB = b.metrics.cvssMetricV2.get(0).impactScore;
            double exploitabilityScoreA = a.metrics.cvssMetricV2.get(0).exploitabilityScore;
            double exploitabilityScoreB = b.metrics.cvssMetricV2.get(0).exploitabilityScore;

            // Compare based on base score, impact score, exploitability score, and ID
            if (baseScoreA != baseScoreB) {
                return Double.compare(baseScoreA, baseScoreB);
            } else if (impactScoreA != impactScoreB) {
                return Double.compare(impactScoreA, impactScoreB);
            } else if (exploitabilityScoreA != exploitabilityScoreB) {
                return Double.compare(exploitabilityScoreA, exploitabilityScoreB);
            } else {
                return a.id.compareTo(b.id);
            }
        }
        return 0; // If any CVSS metric is null, return 0 (equal).
    }

    // Print sorted elements
    void printSorted(Cve[] arr) {
        System.out.println("Sorted elements:");
        System.out.println("Array length: " + arr.length);
        int i = 1;

        for (Cve a : arr) {
            if (a != null && a.metrics != null && a.metrics.cvssMetricV2 != null && !a.metrics.cvssMetricV2.isEmpty()) {
                System.out.println(i + ". element");
                System.out.println("Base Score: " + a.metrics.cvssMetricV2.get(0).cvssData.baseScore);
                System.out.println("Impact Score: " + a.metrics.cvssMetricV2.get(0).impactScore);
                System.out.println("Exploitability Score: " + a.metrics.cvssMetricV2.get(0).exploitabilityScore);
                System.out.println("ID: " + a.id);
                System.out.println();
                i++;
            }
        }
    }
}
